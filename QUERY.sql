1) TASK 1

-- CREATE TABLE
CREATE TABLE customers_dataset (
	customer_id VARCHAR(50),
	customer_unique_id VARCHAR(50),
	customer_zip_code_prefix INT,
	customer_city VARCHAR(50),
	customer_state VARCHAR(5)
);
CREATE TABLE geolocation_dataset (
	geolocation_zip_code_prefix INT,
	geolocation_lat	FLOAT,
	geolocation_lng	FLOAT,
	geolocation_city VARCHAR(50),
	geolocation_state VARCHAR(5)
);
CREATE TABLE order_items_dataset (
	order_id VARCHAR(50),
	order_item_id INT,
	product_id VARCHAR(50),
	seller_id VARCHAR(50),
	shipping_limit_date TIMESTAMP,
	price FLOAT,
	freight_value FLOAT
);
CREATE TABLE order_payments_dataset (
	order_id VARCHAR(50),
	payment_sequential INT,
	payment_type VARCHAR(15),
	payment_installments INT,
	payment_value FLOAT
);
CREATE TABLE order_reviews_dataset (
	review_id VARCHAR(50),
	order_id VARCHAR(50),
	review_score INT,
	review_comment_title VARCHAR(50),
	review_comment_message TEXT,
	review_creation_date TIMESTAMP,
	review_answer_timestamp TIMESTAMP
);
CREATE TABLE orders_dataset (
	order_id VARCHAR(50),
	customer_id VARCHAR(50),
	order_status VARCHAR(15),
	order_purchase_timestamp TIMESTAMP,
	order_approved_at TIMESTAMP,
	order_delivered_carrier_date TIMESTAMP,
	order_delivered_customer_date TIMESTAMP,
	order_estimated_delivery_date TIMESTAMP
);
CREATE TABLE product_dataset (
	product_id VARCHAR(50),
	product_category_name VARCHAR(50),
	product_name_lenght	INT,
	product_description_lenght INT,
	product_photos_qty INT,
	product_weight_g FLOAT,
	product_length_cm FLOAT,
	product_height_cm FLOAT,
	product_width_cm FLOAT
);
CREATE TABLE sellers_dataset (
	seller_id VARCHAR(50),
	seller_zip_code_prefix INT,
	seller_city	VARCHAR(50),
	seller_state VARCHAR(5)
)


-- SELECT SCRIPT
SELECT * FROM customers_dataset LIMIT 10;
SELECT * FROM geolocation_dataset LIMIT 10;
SELECT * FROM order_items_dataset LIMIT 10;
SELECT * FROM order_payments_dataset LIMIT 10;
SELECT * FROM order_reviews_dataset LIMIT 10;
SELECT * FROM orders_dataset LIMIT 10;
SELECT * FROM product_dataset LIMIT 10;
SELECT * FROM sellers_dataset LIMIT 10


-- CEK UNIQUE VALUE
SELECT customer_id, COUNT(customer_id) as jumlah
FROM customers_dataset
GROUP BY customer_id
HAVING COUNT (customer_id) > 1;

SELECT seller_id, COUNT(seller_id) as jumlah
FROM sellers_dataset
GROUP BY seller_id
HAVING COUNT (seller_id) > 1;

SELECT order_id, COUNT(order_id) as jumlah
FROM orders_dataset
GROUP BY order_id
HAVING COUNT (order_id) > 1;

SELECT product_id, COUNT(product_id) as jumlah
FROM product_dataset
GROUP BY product_id
HAVING COUNT (product_id) > 1

-- ALTER CONSTRAINT
ALTER TABLE geolocation_dataset
	ADD CONSTRAINT geolocation_pkey PRIMARY KEY (geolocation_zip_code_prefix);

ALTER TABLE customers_dataset
	ADD CONSTRAINT customer_pkey PRIMARY KEY (customer_id),
	ADD CONSTRAINT customer_fkey FOREIGN KEY (customer_zip_code_prefix) 
		REFERENCES geolocation_dataset (geolocation_zip_code_prefix);
	
ALTER TABLE sellers_dataset
	ADD CONSTRAINT seller_pkey PRIMARY KEY (seller_id),
	ADD CONSTRAINT seller_fkey FOREIGN KEY (seller_zip_code_prefix) 
		REFERENCES geolocation_dataset (geolocation_zip_code_prefix);
	
ALTER TABLE product_dataset
	ADD CONSTRAINT product_pkey PRIMARY KEY (product_id);

ALTER TABLE orders_dataset
	ADD CONSTRAINT order_pkey PRIMARY KEY (order_id),
	ADD CONSTRAINT order_fkey FOREIGN KEY (customer_id) REFERENCES customers_dataset (customer_id);

ALTER TABLE order_items_dataset
	ADD CONSTRAINT item_order_fkey FOREIGN KEY (order_id) REFERENCES orders_dataset(order_id),
	ADD CONSTRAINT item_product_fkey FOREIGN KEY (product_id) REFERENCES product_dataset(product_id),
	ADD CONSTRAINT item_seller_fkey FOREIGN KEY (seller_id) REFERENCES sellers_dataset(seller_id);

ALTER TABLE order_payments_dataset
	ADD CONSTRAINT payment_fkey FOREIGN KEY (order_id) REFERENCES orders_dataset(order_id);

ALTER TABLE order_reviews_dataset
	ADD CONSTRAINT review_fkey FOREIGN KEY (order_id) REFERENCES orders_dataset(order_id);


2) TASK 2

-- CEK: ADA CUSTOMER_UNIQUE_ID YANG MEMILIKI LEBIH DARI 1 CUSTOMER_ID (MEMILIKI DATA YANG SAMA)
-- SEHINGGA PADA TASK 2 AKAN DIGUNAKAN CUSTOMER_UNIQUE_ID

WITH CTE AS (	
    SELECT CUSTOMER_UNIQUE_ID, COUNT(DISTINCT CUSTOMER_ID) as jumlah
    FROM CUSTOMERS_DATASET
    GROUP BY CUSTOMER_UNIQUE_ID
    HAVING COUNT(DISTINCT CUSTOMER_ID) > 1
)
SELECT * 
FROM CUSTOMERS_DATASET
WHERE CUSTOMER_UNIQUE_ID IN (SELECT CUSTOMER_UNIQUE_ID FROM CTE)
ORDER BY CUSTOMER_UNIQUE_ID;


-- SUBTASK 1: RATA-RATA MONTHLY ACTIVE USER (MAU) PER TAHUN

WITH MAU_TABLE AS (
	SELECT 
		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
		EXTRACT(MONTH FROM ORDER_PURCHASE_TIMESTAMP) AS MONTH_ORDER,
		COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS MAU
	FROM ORDERS_DATASET O
	INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
	GROUP BY 1, 2
	)
SELECT YEAR_ORDER, ROUND(AVG(MAU), 2) AS AVG_MAU
FROM MAU_TABLE
GROUP BY 1
ORDER BY 1;


-- SUBTASK 2: TOTAL CUSTOMER BARU PER TAHUN

WITH FIRST_PURCHASE_TABLE AS (
	SELECT 
	    CUSTOMER_UNIQUE_ID, 
	    MIN(ORDER_PURCHASE_TIMESTAMP) AS FIRST_PURCHASE
	FROM ORDERS_DATASET O
	INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
	GROUP BY 1
	)
SELECT EXTRACT(YEAR FROM FIRST_PURCHASE) AS YEAR_ORDER, COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS NEW_CUST
FROM FIRST_PURCHASE_TABLE
GROUP BY 1
ORDER BY 1;


-- SUBTASK 3 JUMLAH CUSTOMER YANG MELAKUKAN REPEAT ORDER PER TAHUN

WITH REPEAT_ORDER_TABLE AS (
    SELECT
        EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
        CUSTOMER_UNIQUE_ID,
        COUNT(ORDER_ID) AS ORDER_FREQ
    FROM ORDERS_DATASET O
    INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
    GROUP BY 1, 2
    HAVING COUNT(ORDER_ID) > 1
)
SELECT YEAR_ORDER, COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS REPEAT_ORDER
FROM REPEAT_ORDER_TABLE
GROUP BY 1;


-- SUBTASK 4 RATA-RATA FREKUENSI ORDER PER TAHUN

WITH ORDER_TABLE AS (
    SELECT
        EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
        CUSTOMER_UNIQUE_ID,
        COUNT(ORDER_ID) AS ORDER_FREQ
    FROM ORDERS_DATASET O
    INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
    GROUP BY 1, 2
)
SELECT YEAR_ORDER, ROUND(AVG(ORDER_FREQ), 2) AS AVG_ORDER_FREQ
FROM ORDER_TABLE
GROUP BY 1;


-- SUBTASK 5 MEMBUAT MASTER TABEL

WITH 
	MAU AS (
	    SELECT YEAR_ORDER, ROUND(AVG(MAU), 2) AS AVG_MAU
	    FROM (
			SELECT 
        		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
        		EXTRACT(MONTH FROM ORDER_PURCHASE_TIMESTAMP) AS MONTH_ORDER,
        		COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS MAU
        	FROM ORDERS_DATASET O
        	INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
        	GROUP BY 1, 2
		) A
		GROUP BY 1
		ORDER BY 1
	),
	NEW_CUST AS (
		SELECT EXTRACT(YEAR FROM FIRST_PURCHASE) AS YEAR_ORDER, COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS NEW_CUST
		FROM (
		    SELECT
		        CUSTOMER_UNIQUE_ID,
		        MIN(ORDER_PURCHASE_TIMESTAMP) AS FIRST_PURCHASE
		    FROM ORDERS_DATASET O
		    INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
		    GROUP BY 1
		) B
		GROUP BY 1
		ORDER BY 1
	),
	REPEAT_ORDER AS (
		SELECT YEAR_ORDER, COUNT(DISTINCT CUSTOMER_UNIQUE_ID) AS REPEAT_ORDER
		FROM (
			SELECT
    			EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
    			CUSTOMER_UNIQUE_ID,
    			COUNT(ORDER_ID) AS ORDER_FREQ
    		FROM ORDERS_DATASET O
    		INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
    		GROUP BY 1, 2
    		HAVING COUNT(ORDER_ID) > 1
    	) C
		GROUP BY 1
	),
	FREQUENCY AS (
		SELECT YEAR_ORDER, ROUND(AVG(ORDER_FREQ), 2) AS AVG_ORDER_FREQ
		FROM (
			SELECT 
        		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
        		CUSTOMER_UNIQUE_ID,
        		COUNT(ORDER_ID) AS ORDER_FREQ
        	FROM ORDERS_DATASET O
        	INNER JOIN CUSTOMERS_DATASET C ON O.CUSTOMER_ID = C.CUSTOMER_ID
        	GROUP BY 1, 2
		) D
		GROUP BY 1
	)
SELECT A.YEAR_ORDER, AVG_MAU, NEW_CUST, REPEAT_ORDER, AVG_ORDER_FREQ
FROM MAU A
INNER JOIN NEW_CUST B ON A.YEAR_ORDER = B.YEAR_ORDER
INNER JOIN REPEAT_ORDER C ON A.YEAR_ORDER = C.YEAR_ORDER
INNER JOIN FREQUENCY D ON A.YEAR_ORDER = D.YEAR_ORDER;


3) TASK 3

-- SUBTASK 1 TABEL TOTAL REVENUE PER TAHUN

SELECT 
	EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER, 
	ROUND(CAST(SUM(PRICE + FREIGHT_VALUE) AS NUMERIC), 2) AS TOTAL_REVENUE
--INTO TABLE REVENUE
FROM ORDER_ITEMS_DATASET I
INNER JOIN ORDERS_DATASET O ON I.ORDER_ID = O.ORDER_ID
WHERE ORDER_STATUS = 'delivered'
GROUP BY 1
ORDER BY 1;


-- SUBTASK 2 TABEL TOTAL CANCELED ORDER PER TAHUN

SELECT 
	EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER, 
	COUNT(*) AS TOTAL_CANCELED
--INTO TABLE CANCELED_ORDER
FROM ORDERS_DATASET
WHERE ORDER_STATUS = 'canceled'
GROUP BY 1
ORDER BY 1;


-- SUBTASK 3 TABEL KATEGORI YANG MEMILIKI TOTAL REVENUE TERTINGGI PER TAHUN

WITH RANKING AS (
	SELECT 
		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
		PRODUCT_CATEGORY_NAME,
		ROUND(CAST(SUM(PRICE + FREIGHT_VALUE) AS NUMERIC), 2) AS REVENUE,
		RANK () OVER (PARTITION BY EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) 
					  ORDER BY ROUND(CAST(SUM(PRICE + FREIGHT_VALUE) AS NUMERIC), 2) DESC)
	FROM ORDER_ITEMS_DATASET I
	INNER JOIN ORDERS_DATASET O ON I.ORDER_ID = O.ORDER_ID
	INNER JOIN PRODUCT_DATASET P ON I.PRODUCT_ID = P.PRODUCT_ID
	WHERE ORDER_STATUS = 'delivered'
	GROUP BY 1,2
)
SELECT YEAR_ORDER, PRODUCT_CATEGORY_NAME, REVENUE
--INTO TABLE REVENUE_CATEGORY
FROM RANKING
WHERE RANK = 1;


-- SUBTASK 4 TABEL KATEGORI YANG MEMILIKI TOTAL CANCELED TERTINGGI PER TAHUN

WITH RANKING AS (
	SELECT 
		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR_ORDER,
		PRODUCT_CATEGORY_NAME,
		COUNT(*) AS CANCELED,
		RANK () OVER (PARTITION BY EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) 
					  ORDER BY COUNT(*) DESC)
	FROM ORDER_ITEMS_DATASET I
	INNER JOIN ORDERS_DATASET O ON I.ORDER_ID = O.ORDER_ID
	INNER JOIN PRODUCT_DATASET P ON I.PRODUCT_ID = P.PRODUCT_ID
	WHERE ORDER_STATUS = 'canceled'
	GROUP BY 1,2
)
SELECT YEAR_ORDER, PRODUCT_CATEGORY_NAME, CANCELED
--INTO TABLE CANCELED_CATEGORY
FROM RANKING
WHERE RANK = 1;

-- SUBTASK 5 MENAMPILKAN KEEMPAT TABEL DIATAS

SELECT 
	R.YEAR_ORDER, 
	TOTAL_REVENUE,
	RC.PRODUCT_CATEGORY_NAME AS TOP_REVENUE_PRODUCT, 
	REVENUE,
	TOTAL_CANCELED,
	CC.PRODUCT_CATEGORY_NAME AS TOP_CANCELED_PRODUCT, 
	CANCELED
FROM REVENUE R
INNER JOIN CANCELED_ORDER C ON R.YEAR_ORDER = C.YEAR_ORDER
INNER JOIN REVENUE_CATEGORY RC ON R.YEAR_ORDER = RC.YEAR_ORDER
INNER JOIN CANCELED_CATEGORY CC ON R.YEAR_ORDER = CC.YEAR_ORDER;
	

4) TASK 4

-- SUBTASK 1 PAYMENT USAGE ALL TIME

WITH PAYMENT AS (
	SELECT 
		DISTINCT PAYMENT_TYPE,
		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR,
		COUNT(*) AS USAGE_COUNT,
		RANK() OVER(PARTITION BY PAYMENT_TYPE ORDER BY COUNT(*) DESC)
	FROM ORDER_PAYMENTS_DATASET P
	INNER JOIN ORDERS_DATASET O ON P.ORDER_ID = O.ORDER_ID
	GROUP BY 1,2
), 
PAYMENT_TOTAL AS (
	SELECT PAYMENT_TYPE, COUNT(*) AS USAGE_TOTAL
	FROM ORDER_PAYMENTS_DATASET
	GROUP BY 1
	ORDER BY 2 DESC
)
SELECT P.PAYMENT_TYPE, USAGE_TOTAL, YEAR AS TOP_YEAR, USAGE_COUNT
FROM PAYMENT P
INNER JOIN PAYMENT_TOTAL PT ON P.PAYMENT_TYPE = PT.PAYMENT_TYPE
WHERE RANK = 1
ORDER BY USAGE_TOTAL DESC


-- SUBTASK 2 PAYMENT USAGE PER TAHUN

WITH PAYMENT AS (
	SELECT 
		DISTINCT PAYMENT_TYPE,
		EXTRACT(YEAR FROM ORDER_PURCHASE_TIMESTAMP) AS YEAR,
		COUNT(*) AS USAGE_COUNT
	FROM ORDER_PAYMENTS_DATASET P
	INNER JOIN ORDERS_DATASET O ON P.ORDER_ID = O.ORDER_ID
	GROUP BY 1,2
),
PAYMENT_DETAIL AS (
	SELECT 
		PAYMENT_TYPE,
		SUM(CASE WHEN YEAR = 2016 THEN USAGE_COUNT ELSE 0 END) AS YEAR_2016,
		SUM(CASE WHEN YEAR = 2017 THEN USAGE_COUNT ELSE 0 END) AS YEAR_2017,
		SUM(CASE WHEN YEAR = 2018 THEN USAGE_COUNT ELSE 0 END) AS YEAR_2018
	FROM PAYMENT 
	GROUP BY 1
)
SELECT 
	PAYMENT_TYPE, 
	YEAR_2016,
	YEAR_2017,
	YEAR_2018,
	CASE 
		WHEN YEAR_2017 != 0 THEN ROUND(((YEAR_2018-YEAR_2017)/YEAR_2017)*100, 2)
		ELSE NULL
	END AS DELTA
FROM PAYMENT_DETAIL
ORDER BY DELTA DESC
	
